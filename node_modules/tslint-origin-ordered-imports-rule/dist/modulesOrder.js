"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var ModulesOrder = /** @class */ (function () {
    function ModulesOrder(optionsItems) {
        this.groupIndex = 0;
        var hasLib = optionsItems.some(function (_) { return _ === ModuleType.Lib; });
        var hasUser = optionsItems.some(function (_) { return _ === ModuleType.User; });
        if (!hasLib) {
            optionsItems = [ModuleType.Lib].concat(optionsItems);
        }
        if (!hasUser) {
            optionsItems = optionsItems.concat([ModuleType.User]);
        }
        this.importGroups = optionsItems.map(function (_, i) { return new ImportGroup(_, i); });
    }
    ModulesOrder.prototype.check = function (path) {
        // built-in ModuleTypes can intersect with CustomRules so first we try to find something among CustomRules
        var index = this.importGroups
            .slice(this.groupIndex)
            .findIndex(function (item) { return item.type === ModuleType.CustomRule && item.check(path); });
        if (index === -1) {
            index = this.importGroups
                .slice(this.groupIndex)
                .findIndex(function (item) { return item.type !== ModuleType.CustomRule && item.check(path); });
        }
        if (index === -1) {
            return false;
        }
        this.groupIndex += index;
        return true;
    };
    ModulesOrder.prototype.findImportGroup = function (path) {
        var _this = this;
        return this.findImportGroupIndexWith(function (index) { return _this.importGroups[index]; }, path);
    };
    ModulesOrder.prototype.getCurrentImportGroup = function () {
        return this.importGroups[this.groupIndex];
    };
    ModulesOrder.prototype.findImportGroupIndexWith = function (customizer, path) {
        // built-in ModuleTypes can intersect with CustomRules so first we try to find something among CustomRules
        var customIndex = this.importGroups
            .findIndex(function (item) { return item.type === ModuleType.CustomRule && item.check(path); });
        if (customIndex > -1) {
            return customizer(customIndex);
        }
        return customizer(this.importGroups
            .findIndex(function (item) { return item.check(path); }));
    };
    return ModulesOrder;
}());
exports.default = ModulesOrder;
var ModuleType;
(function (ModuleType) {
    ModuleType["Lib"] = "lib";
    ModuleType["User"] = "user";
    ModuleType["CustomRule"] = "custom-rule";
})(ModuleType = exports.ModuleType || (exports.ModuleType = {}));
var ImportGroup = /** @class */ (function () {
    function ImportGroup(optionsItem, index) {
        this.index = index;
        if (utils_1.enumHas(ModuleType, optionsItem)) {
            this.type = optionsItem;
        }
        else {
            this.type = ModuleType.CustomRule;
            this.customRule = new RegExp(optionsItem);
        }
    }
    ImportGroup.prototype.check = function (path) {
        if (this.type === ModuleType.CustomRule) {
            return this.customRule.test(path);
        }
        var isUserModule = path.startsWith('/') || path.startsWith('.');
        if (this.type === ModuleType.User && isUserModule) {
            return true;
        }
        if (this.type === ModuleType.Lib && !isUserModule) {
            return true;
        }
        return false;
    };
    ImportGroup.prototype.getTitle = function () {
        switch (this.type) {
            case ModuleType.Lib:
                return 'Lib import';
            case ModuleType.User:
                return 'User import';
            case ModuleType.CustomRule:
                return "Custom import " + this.customRule.toString();
        }
    };
    return ImportGroup;
}());
exports.ImportGroup = ImportGroup;
//# sourceMappingURL=/home/marcuzy/code/github/tslint-origin-ordered-imports-rule/dist/modulesOrder.js.map